# 1. 메모리 단편화

![메모리 단편화](/Resources/Images/메모리%20단편화.png)  

- <b>메모리 단편화(Memory Fragmentation)</b>는 컴퓨터의 메모리 공간이 효율적으로 사용되지 못하고, 작은 조각들로 나뉘어 낭비되는 현상을 말함
- 이는 마치 퍼즐 조각들 사이에 빈 공간이 생기는 것과 비슷
- 빈 공간들은 개별적으로는 작지만, 전체적으로 합치면 상당한 양의 메모리가 낭비될 수 있음  
- 이러한 메모리 단편화는 <b>외부 단편화</b>와 <b>내부 단편화</b>로 분류됨 

### 외부 단편화(External Fragmentation)

![External Fragmentation](/Resources/Images/External-Fragmentation.png)  

- 메모리 할당과 해제가 반복되면서, 메모리 공간 사이에 작은 빈 공간들이 생기는 현상
- ❌이 빈 공간들이 모여 있지 않고 흩어져 있어서, 전체 빈 공간의 크기는 충분하지만 연속된 큰 메모리 블록을 할당할 수 없게 됨

### 내부 단편화(Internal Fragmentation)

![Internal Fragmentation](/Resources/Images/Internal-Fragmentation.png)  

- 프로그램이 요청한 것보다 더 큰 메모리 블록이 할당될 때 발생하는 현상
- 할당된 메모리와 실제 사용되는 메모리 사이의 차이가 낭비됨

> <b>❓예시</b>  
> 프로그램이 97 byte를 요청했는데, 시스템이 100 byte 단위로만 할당할 수 있다면 > 3 byte가 낭비됨  

<br>

# 2. 메모리 단편화가 발생하는 상황
### 외부 단편화 발생 상황
> <b>📌동적 메모리 할당의 반복</b>  
> - 프로그램들이 실행되고 종료되는 과정에서 메모리가 할당되고 해제되는 것이 반복됨  
> - 시간이 지남에 따라 메모리 공간은 다양한 크기의 할당된 블록과 빈 블록들이 섞인 모자이크 상태가 됨  

> <b>📌가변 크기 메모리 할당</b>  
> - 프로그램마다 다양한 크기의 메모리를 요청하고, 이로 인해 할당과 해제 후 불규칙한 크기의 빈 공간이 남게 됨  

### 내부 단편화 발생 상황
> <b>📌고정 크기 메모리 할당</b>  
> - 메모리 관리를 단순화하기 위해, 고정된 크기의 블록으로 메모리를 할당할 때 발생  
> - ex. [페이징 시스템(Paging System)](/OS/Paging-System.md)에서의 마지막 페이지가 완전히 채워지지 않을 때  

> <b>📌메모리 정렬 요구사항</b>  
> - 하드웨어가 특정 경계에 맞춰 메모리 주소를 정렬해야 할 때  
> ex. 64-bit 시스템에서 데이터가 8 byte 경계에 맞춰줘야 할 때  

<br>

# 3. 메모리 단편화를 해결해야 하는 이유
### ❌시스템 성능 저하
- 사용 가능한 총 메모리의 양은 충분하지만, 단편화로 인해 새로운 프로세스에게 메모리를 할당할 수 없는 상황이 발생할 수 있음
- 이것은 마치, <b>서랍 여러 곳에 동전이 흩어져 있어 총액은 충분하지만, 한 번에 큰 금액을 지불하기 어려운 상황</b>과 유사함

### ❌메모리 낭비
- 단편화된 메모리는 실제로 사용되지 않지만, 다른 프로세스에 할당할 수도 없어서 낭비됨
- 이는 제한된 메모리 자원을 비효율적으로 사용하게 만듦

### ❌프로그램 실행 실패
- 충분한 연속된 메모리 공간이 없으면, 새로운 프로그램이 시작되지 못하거나 실행 중인 프로그램이 더 많은 메모리를 할당받지 못할 수 있음  

### ❌시스템 불안정성 증가
- 심한 메모리 단편화는 시스템 크래시나 성능 저하로 이어질 수 있음

<br>

# 4. 메모리 단편화를 해결하는 방법
## 📌외부 단편화 해결 방법
### 1) 메모리 압축(Compaction)

- 사용 중인 메모리 블록들을 메모리의 한 쪽 끝으로 이동시켜, 빈 공간들을 하나의 연속된 블록으로 만드는 방법
- 이는 마치, 책장에서 책들을 한 쪽으로 몰아두어 큰 공간을 만드는 것과 유사함

| <b>장점</b> | 효과적으로 단편화를 해결할 수 있음 |
| --- | --- |
| <b>단점</b> | 실행 중인 프로세스를 일시 중지하고, 데이터를 이동시켜야 하므로 오버헤드가 큼 |

### 2) 메모리 할당 알고리즘 최적화

- <b>`First-Fit`</b>: 요청된 크기를 수용할 수 있는 첫 번째 빈 공간에 할당
- <b>`Best-Fit`</b>: 요청된 크기를 수용할 수 있는 가장 작은 빈 공간에 할당
- <b>`Worst-Fit`</b>: 가장 큰 빈 공간에 할당하여 남는 공간이 유의미한 크기가 되도록 함
- 각 알고리즘은 장단점이 있으며, 상황에 따라 적절한 선택이 필요  

### 3) 페이징(Paging)

- 물리적 메모리를 <b>고정 크기의 블록(페이지 프레임)</b>으로 나누고, 프로세스의 가상 메모리도 같은 크기의 블록(페이지)로 나눔
- 이렇게 하면, 연속되지 않은 물리적 메모리 페이지 프레임에 논리적 페이지를 매핑할 수 있음
- 외부 단편화를 제거하지만, 내부 단편화가 발생할 수 있음

### 4) 세그먼테이션(Segmentation)
- 프로세스를 <b>논리적 단위(세그먼트)</b>로 나누고, 각 세그먼트에 메모리를 할당
- 세그먼트는 가변 크기를 가질 수 있어 내부 단편화는 줄지만, 외부 단편화가 여전히 문제가 될 수 있음  

## 📌외부 단편화 해결 방법
### 1) 가변 크기 메모리 할당
- 요청된 정확한 크기의 메모리를 할당하는 방식
- 단, 외부 단편화 문제를 증가시킬 수 있음

### 2) 버디 시스템(Buddy System)
- 메모리를 2의 거듭제곱 크기의 블록으로 관리
- 필요한 크기의 블록을 찾기 위해, 큰 블록을 반복적으로 반으로 나눔
- 메모리 해제 시, 인접한 빈 블록들을 합쳐서 더 큰 블록을 형성
- 내부 단편화를 완전히 제거하지는 못하지만 관리가 용이

### 3) 슬랩 할당(Slab Allocation)
- 자주 사용되는 객체들을 위한 메모리 풀을 미리 할당
- 같은 크기의 객체들은 같은 슬랩에 할당되어 내부 단편화를 최소화
- 커널 수준의 메모리 관리에 특히 유용

## 📌통합적 접근 방법
### 1) 가상 메모리 (Virtual Memory)
- 디스크의 일부를 메모리의 확장으로 사용
- 페이징과 세그먼테이션을 결합하여 더 효율적인 메모리 관리가 가능
- 물리적 메모리 제약을 넘어 더 큰 주소 공간을 제공

### 2) 가비지 컬렉션(Garbage Collection)
- 더 이상 사용되지 않는 메모리를 자동으로 식별하고 해제
- Java, Python, C#과 같은 많은 현대 프로그래밍 언어에서 사용
- 프로그래머의 수동 메모리 관리 부담을 줄이고 메모리 누수를 방지하는 효과를 제공
