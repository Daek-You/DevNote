# 1. 주소 바인딩(Address Binding)이란?

<img src="https://osmemorymanagement.home.blog/wp-content/uploads/2020/01/screenshot_3.png" width="1200"/>  

- 프로그램이 실행되려면, 프로그램의 명령어와 데이터가 <b>메모리의 어느 위치에 저장</b>될지 결정되어야 함
- 이런 과정을 <b>주소 바인딩(Address Binding)</b>이라고 하며, CPU가 만들어 낸 논리적 주소를 `MMU(Memory Management Unit)`을 통해 실제 물리적 메모리 주소로 매핑하는 과정을 말함
    - 메모리 관리와 관련하여 좀 더 자세한 내용은 [Memory Management](/OS/Memory%20Management.md)를 참고
- 주소 바인딩은 프로그램의 생명 주기에서 서로 다른 3가지 시점에 이루어질 수 있음
- 이러한 각 주소 바인딩 방식에 대해 알아보기 전에, 먼저 <b>프로그램이 메모리에 올라가 어떻게 실행되는지에 대한 과정</b>을 먼저 숙지해야 함

<br>

# 2. 프로그램이 실행되는 과정
### 📌1) 컴파일 타임(Compile Time)

![컴파일 타임](/Resources/Images/컴파일%20타임.png)  

- 우리가 작성한 프로그램을 실행 파일로 만들기 위해선, 먼저 `컴파일(Compile)` 과정을 진행해야 함
- 컴파일이란, 고급 언어(ex. C, C++)로 작성된 소스 코드를 <b>컴퓨터가 알아들을 수 있는 바이너리 이진수로 변환하는 작업</b>을 말함
- 고급 언어에서 바로 바이너리로 변환되는 것은 아니고, 중간에 `어셈블리(Assembly)`라는 언어로 바뀐 뒤, 어셈블리가 바이너리로 변환되는 것
- 이러한 과정을 거치면 컴퓨터가 알아들을 수 있는 바이너리 파일(`Obj file`)이 생성될 것이며, 이렇게 변환되는 단계를 `컴파일 타임(Compile Time)`이라고 함

### 📌2) 로드 타임(Load Time)
![로드 타임](/Resources/Images/Load-time.png)  

- 단순하고 간단한 프로그램이라면 `obj file`이 하나만 있겠지만, <b>대형 프로그램이라면 또 다른 `obj file`과 `obj library file`도 존재</b>할 것임
- 이러한 여러 `obj file`들을 하나로 묶어, <b>하나의 모듈로 통합</b>해주는 역할을 수행하는 게 `Linkage Editor(Linker)`
    - `Linkage Editor(Linker)`가 여러 `obj file`들을 모아 하나로 통합해주면, <b>`통합 obj 모듈(Load Module)`</b>이 되고, 이것을 메모리에 올려주면 됨
- 이렇게 생성된 `Load Module` 파일에 <b>필요한 라이브러리들(ex. System Library)</b>들을 넣어 하나의 프로그램 형태로 만들고, 이를 `Loader`에게 전달하여 메모리에 올림  

> ❓시스템 라이브러리(System Library)  
> 운영체제에서 실행하는 데 필요한 기본 기능(입출력, 메모리 관리, 파일 시스템 접근 등)을 제공하는 라이브러리  

- 이 단계를 <b>`로드 타임(Load Time)`</b>이라고 부름

### 📌3) 실행 타임(Execution Time 또는 Runtime)

![Runtime](/Resources/Images/runtime.png)  

- 프로그램이 실제로 메모리에 로드된 후, CPU에 의해 실행되는 단계
- 로드 타임이 끝난 이후, 프로그램이 실제로 동작하는 모든 시간을 포함
- 이 단계에 들어서면 운영체제는 프로그램의 첫 번째 명령어를 실행하기 위해 CPU의 제어권을 해당 프로그램에게 넘기며, 프로그램의 진입점(Entry point)에서 실행이 시작됨
- 실행 과정에서 필요한 라이브러리(`DLL`, `.so` 파일 등)는 프로그램이 실행되는 시점 또는 특정 기능이 호출되는데, 이를 [Dynamic Linking](/OS/메모리%20할당%20보조%20기법.md)이라고 함

<br>

# 3. 타임별 주소 바인딩

- 위에서 프로그램이 실행되는 과정을 각 단계별로 자세히 알아보았음
- 주소 바인딩 또한 위에서 알아 본 3가지 단계 중에 적절히 골라서 메모리 주소 매핑이 일어남
- 개발자가 컴파일 옵션이나 개발 방식을 통해 일정 부분 제어할 순 있지만, 주소 바인딩은 보통 시스템 아키텍처나 운영체제에 의해 기본적으로 결정되는 경우가 많음

### 1) 컴파일 타임 바인딩(Compile Time Binding)

- 프로그램이 <b>컴파일될 때</b> 메모리 주소가 결정됨
- 가장 초기의 바인딩되는 방식이며, <b>프로그램이 메모리에 올라가기도 전에 주소값이 결정</b>됨
- 컴파일러는 소스 코드를 기계어로 변환하면서 모든 메모리 참조를 실제 물리적 메모리 주소로 변환하며, 이 과정에서 <b>`절대 코드(Absolute Code)`</b>가 생성됨
    - <b>절대 코드</b>라는 말은 메모리의 주소값이 절대적으로 고정되어 있다는 걸 의미
    - 즉, 명령어가 있는 메모리의 위치를 더 이상 바꿀 수 없음
    - 바꾸려면 재컴파일을 해야 함
- 프로그램이 시작될 때 항상 동일한 물리적 메모리 위치에 로드됨
- MS-DOS의 .COM 파일, 초기 임베디드 시스템에서 사용되었음

| ✅장점 | ❌단점 |
| --- | --- |
| 런타임 오버헤드가 없어 실행 속도가 빠르고, 구현이 단순 | 유연성이 매우 낮고, 메모리 위치 변경 시 프로그램 재컴파일 필요 |
| | 절대 주소가 같은 2개 이상의 프로그램은 실행 불가 (재컴파일 필요) |
| | 장치가 어떻게 구성되어 있는지 파악해야 함 (메모리는 4GB짜리인데, 그 이상의 주소값 부여 X) |

### 2) 로드 타임 바인딩(Load Time Binding)

- 프로그램이 <b>메모리에 로드될 때</b> 주소가 결정됨
- <b>`재배치 가능 코드(Relocatable Code)`</b> 또는 <b>`상대 코드(Relative Code)`</b>가 생성됨
- 이 코드에서는 주소 참조가 상대적이며, <b>베이스(base) 주소값이 비어 있음</b>
- 로드 시점에 `Loader`가 프로그램을 메모리의 실제 위치에 배치하고, 빈 베이스 주소를 채워 넣음
- 프로그램이 <b>메모리에 로드된 후에는 그 주소가 고정됨</b>
    - 만약, 프로그램이 스왑 아웃(Swapped out)되었다가 다시 메모리에 돌아올 땐, <b>같은 메모리 위치로 돌아와야 함</b>
- 초기 다중 프로그래밍 시스템, 일부 배치 처리 시스템에서 사용되었음

| ✅장점 | ❌단점 |
| --- | --- |
| 컴파일 타임 바인딩보다 유연하며, 프로그램이 메모리의 다른 위치에 로드될 수 있음 | 메모리에 로드된 후에는 프로그램 실행 중 위치를 변경할 수 없고, 로드 과정에 추가적인 시간이 소요됨 |

### 3) 실행 타임 바인딩(Execution Time Binding)

<img src="https://osmemorymanagement.home.blog/wp-content/uploads/2020/01/screenshot_2.png" width="1200"/>  

- <b>프로그램이 실행 중일 때 주소가 결졍되며, 실행 중에도 변경될 수 있는 가장 유연한 방식</b>
- 프로그램에서 사용하는 주소는 <b>논리적 주소(가상 주소)</b>이며, 프로그램이 실행될 때마다 <b>특수 하드웨어(MMU)가 논리적 주소를 물리적 주소로 변환</b>
- 바인딩은 명령어가 실제로 실행되는 순간까지 지연됨
- 현대 운영체제(Windows, Linux, macOS 등), 가상 메모리 시스템에서 사용하는 바인딩 체계

| ✅장점 | ❌단점 |
| --- | --- |
| 가장 유연한 방식으로, 프로그램이 실행 중에도 메모리 위치를 변경할 수 있고, 메모리를 가장 효율적으로 활용할 수 있음 | 주소 변환에 따른 오버헤드가 있고, 하드웨어(MMU)의 지원이 필요하며, 구현이 복잡 |
