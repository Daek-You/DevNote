# 1. 연결 리스트(Linked List)란?

<img src="https://media.geeksforgeeks.org/wp-content/uploads/20220712172013/Singlelinkedlist.png" width="1200"/>  

- [배열(Array)](/Data%20Structure/Array.md)과 달리, 연결 리스트는 데이터 요소들이 메모리 상에 연속적으로 저장되지 않고, <b>`노드(Node)`</b>라는 개별 단위로 구성된 자료구조를 말함
- 각 노드는 2가지 핵심 부분으로 이루어져 있음
    1. <b>데이터 필드</b>: 저장하고자 하는 실제 값 (ex. 정수, 문자, 객체 등)
    2. <b>링크 필드</b>: 다음 노드의 위치를 가리키는 [포인터(Pointer)](https://www.tcpschool.com/c/c_pointer_intro) 👉🏻 메모리 주소 값  

### 연결 리스트의 주요 용어들

- <b>헤드(Head)</b>: 리스트의 첫 번째 노드
- <b>테일(Tail)</b>: 리스트의 마지막 노드
- <b>노드(Node)</b>: 데이터와 포인터로 구성된 기본 단위
- <b>링크(Link)</b>: 다음 노드를 가리키는 포인터  

### 연결 리스트의 특징

- 크기가 고정되는 배열과 달리, 연결 리스트는 <b>메모리에 연속적으로 저장될 필요가 없어 크기가 유연하게 변할 수 있음</b>
- 마치 [기차](https://namu.wiki/w/%EA%B8%B0%EC%B0%A8)처럼 각 칸(노드)이 연결되어 있으며, 필요에 따라 칸을 추가하거나 제거할 수 있음  

### 연결 리스트의 활용 사례

- <b>메모리 관리</b>: 운영체제에서 사용 가능한 메모리 블록 관리
- <b>재생 목록</b>: 음악 플레이어의 재생 목록 (특히 환형 리스트)
- <b>웹 브라우저 탐색</b>: 웹 브라우저의 앞으로/뒤로 가기 기능 (이중 연결 리스트)
- <b>이미지 뷰어</b>: 이전/다음 이미지 탐색
- <b>해시 테이블</b>: 충돌 해결을 위한 체이닝 방식에서 활용
- <b>스택과 큐</b>: 연결 리스트 기반 스택 및 큐 구현  

<br>

# 2. 연결 리스트의 종류
### 단일 연결 리스트 (Singly Linked List) 

![Singly Linked List](https://miro.medium.com/v2/resize:fit:786/format:webp/1*KUTl_WIqHSUg1aoZaMvebQ.png)  

- 연결 리스트의 가장 기본적인 형태로, 각 노드가 다음 노드만을 가리키는 단방향 구조
- 각 노드는 데이터와 다음 노드로의 포인터 정보만 가짐
- 마지막 노드의 포인터는 가리킬 다음 노드가 없으므로, 아무것도 가리키지 않음 (`NULL`)
- 한 방향으로만 이동 가능 (헤드 👉🏻 테일)  

> <b>ℹ️실생활 비유</b>  
> 한 방향 일방통행 도로와 같이, 뒤로 돌아갈 수 없고 앞으로만 이동할 수 있습니다.  

<br>

### 이중 연결 리스트 (Doubly Linked List)

![Doubly Linked List](https://www.boardinfinity.com/blog/content/images/2022/11/Untitled-design--16-.jpg)  

- 이중 연결 리스트는 각 노드가 이전 노드와 다음 노드를 모두 가리키는 구조
- 각 노드는 데이터, 이전 노드에 대한 포인터, 다음 노드에 대한 포인터를 가짐
- 양방향 탐색이 가능하여 앞뒤로 이동이 가능
- 메모리를 더 사용하지만, 이전 노드로의 접근이 쉬움  

> <b>ℹ️실생활 비유</b>  
> 양방향 도로처럼 앞으로도, 뒤로도 이동할 수 있어 더 자유롭게 이동 가능합니다.  

<br>

### 환형 연결 리스트 (Circular Linked List)

![Circular Linked List](https://d14qv6cm1t62pm.cloudfront.net/ccbp-website/Blogs/home/circular-linked-list-in-data-structure-type-and-its-implementation-image-3.png)  

- 마지막 노드가 첫 번째 노드를 가리켜 원형을 이루는 구조 👉🏻 단일 연결 리스트를 환형 리스트로 만든 버전
- 또는 위 그림과 같이, 이중 연결 리스트를 환형 리스트로 구현하여 헤드 노드의 이전 포인터를 테일 노드를 가리켜 양방향 순환을 구성할 수도 있음  

> <b>ℹ️실생활 비유</b>  
> 순환 도로나 회전 목마처럼 끝이 없이 계속 순환할 수 있습니다. 

<br>

# 3. 연결 리스트의 주요 연산
### 노드 추가(Insertion)
> <b>연결 리스트에 새로운 노드를 추가하는 과정</b>  

1. <b>리스트 앞에 추가</b>: 새 노드를 생성하고 그 노드의 포인터를 현재 헤드로 설정한 후, 헤드를 새 노드로 업데이트
2. <b>리스트 끝에 추가</b>: 테일 노드를 찾아 그 노드의 포인터가 새 노드를 가리키도록 설정
3. <b>중간에 추가</b>: 특정 위치 이전 노드의 포인터를 새 노드로, 새 노드의 포인터를 다음 노드로 설정  

### 노드 삭제(Deletion)
> <b>연결 리스트에서 노드를 제거하는 과정</b>  

1. <b>첫 번째 노드 삭제</b>: 헤드를 두 번째 노드로 업데이트
2. <b>마지막 노드 삭제</b>: 이전 노드의 포인터를 null로 설정
3. <b>중간 노드 삭제</b>: 이전 노드의 포인터가 삭제할 노드의 다음 노드를 가리키도록 설정  

### 노드 탐색(Traversal)
> <b>연결 리스트의 모든 노드를 방문하는 과정</b>  

1. 헤드 노드부터 시작
2. 현재 노드의 데이터 처리
3. 현재 노드의 포인터를 따라 다음 노드로 이동
4. 포인터가 null이 될 때까지 반복 (환형 리스트의 경우 처음 노드로 돌아올 때까지)  

<br>

# 4. 연결 리스트의 장단점
### 장점
1. <b>동적 크기</b>: 미리 크기를 정할 필요 없이 실행 중에 크기가 변할 수 있음
2. <b>효율적인 삽입/삭제</b>: 노드의 위치만 알고 있다면 $\mathrm{O(1)}$ 시간에 삽입/삭제 가능
3. <b>메모리 효율성</b>: 필요한 만큼만 메모리 할당 (배열처럼 미리 큰 공간 확보 필요 없음)
4. <b>데이터 재구성 용이</b>: 노드 간의 링크만 변경하면 되므로 데이터 순서 변경이 쉬움

### 단점
1. <b>임의 접근(Random Access) 불가</b>: 특정 위치의 노드에 접근하려면 헤드부터 순차적으로 탐색해야 함
2. <b>추가 메모리 사용</b>: 각 노드마다 포인터 저장을 위한 추가 메모리 필요 (4~8바이트)
3. <b>캐시 지역성 부족</b>: 노드들이 메모리에 연속적으로 저장되지 않아 캐시 효율성 저하
4. <b>역방향 탐색 어려움</b>: 단일 연결 리스트에서는 이전 노드로 돌아가기 어려움

### 시간 복잡도

| 연산 | 시간 복잡도 | 설명 |
| --- | --- | --- |
| <b>접근(Access)</b> | $\mathrm{O(N)}$ | 특정 위치의 노드에 접근하려면 헤드부터 순차 탐색 필요 |
| <b>탐색(Search)</b> | $\mathrm{O(N)}$ | 특정 값을 찾기 위해 리스트 전체 순회 필요 |
| <b>삽입(Insertion)</b> | $\mathrm{O(1)}$ | 삽입 위치를 알고 있다면 상수 시간에 가능 |
| <b>삭제(Deletion)</b> | $\mathrm{O(1)}$ | 삭제 위치를 알고 있다면 상수 시간에 가능 |  

> ❗위치를 모르는 경우 먼저 $\mathrm{O(N)}$ 시간에 위치를 찾아야 합니다.  

### 연결 리스트를 사용하기 좋은 상황

1. <b>데이터 크기를 예측하기 어려울 때</b>: 미리 크기를 정할 필요 없이 동적으로 확장 가능
2. <b>삽입/삭제가 빈번할 때</b>: 특히 리스트 중간에 요소를 자주 추가하거나 제거하는 경우
3. <b>데이터 순서를 자주 재구성할 때</b>: 노드의 포인터만 변경하면 되므로 효율적
4. <b>메모리를 효율적으로 사용해야 할 때</b>: 필요한 만큼만 메모리 할당  
