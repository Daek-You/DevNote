# 1. 큐(Queue)란?

<img src="https://velog.velcdn.com/images/yyj8771/post/37fbed56-46a8-4617-8a2f-c3143b1a40ed/image.png" width="1200">  

- 큐는 <b>선입선출(FIFO, First-In-First-Out)</b> 원칙을 따르는 선형 자료구조
- 마치 은행이나 슈퍼마켓의 대기줄 같이, 가장 먼저 줄을 선 사람이 가장 먼저 서비스를 받는 방식과 동일
- [스택(Stack)](/Data%20Structure/Stack.md)과 달리, 큐는 <b>데이터의 입구와 출구가 서로 분리</b>되어 있음

### 큐의 주요 특징

1. 데이터는 항상 <b>한쪽 끝(후단, Rear)에서만 삽입</b>되고, <b>다른 쪽 끝(전단, Front)에서만 삭제</b>된다.  
2. 가장 먼저 들어온 데이터가 가장 먼저 나가는 <b>선입선출(FIFO)</b> 구조이다.  
3. 큐의 가장 앞 요소를 <b>전단(Front)</b>, 가장 뒷 요소를 <b>후단(Rear)</b>이라고 부른다.

### 큐의 기본 연산

1. <b>`Enqueue`</b>: 큐의 뒤쪽(Rear)에 새로운 요소를 추가하는 연산  
2. <b>`Dequeue`</b>: 큐의 앞쪽(Front)에서 요소를 제거하고 반환하는 연산  
3. <b>`Peek/Front`</b>: 큐의 맨 앞 요소를 제거하지 않고 확인하는 연산  
4. <b>`isEmpty`</b>: 큐가 비어있는지 확인하는 연산  
5. <b>`isFull`</b>: 큐가 가득 찼는지 확인하는 연산 (배열 기반 구현 시)  

### 큐의 활용 사례

> <b>📌운영체제의 작업 스케줄링</b>  
> - CPU가 처리할 작업들이 대기하는 Ready Queue  
> - 프린터와 같은 장치에서 인쇄 작업이 대기하는 인쇄 대기열  

> <b>📌네트워크 패킷 처리</b>  
> - 라우터나 스위치에서 패킷이 대기하는 네트워크 버퍼  

> <b>📌이벤트 처리</b>  
> - 웹 서버에서 클라이언트의 요청을 처리하는 이벤트 큐  
> - 사용자 인터페이스에서 사용자 입력 이벤트 처리  

> <b>📌너비 우선 탐색(BFS, Breadth-First Search)</b>  
> - [그래프(Graph)](/Data%20Structure/Graph%20Overview.md)나 [트리(Tree)](/Data%20Structure/Tree%20Overview.md) 구조에서 너비 우선 탐색 알고리즘 구현  

> <b>📌캐시 관리</b>  
> - 특히 LRU(Least Recently Used) 캐시 구현에 활용  

> <b>📌실시간 시스템</b>  
> - 메시지나 작업을 순서대로 처리해야 하는 실시간 시스템  

<br>

# 2. 큐의 구현 방법
### 1) 일반 배열 기반 큐

- 가장 단순한 배열 기반 큐는 배열의 한 쪽 끝에서 삽입하고, 다른 쪽에서 삭제하는 방식
- 하지만, 이 방식은 <b>심각한 문제점</b>이 존재  

> <b>❌배열 기반 큐의 문제점</b>  
> ![배열 기반 큐의 문제점 이미지](/Resources/Images/배열%20기반%20큐의%20문제점.png)  
> <b>1. 큐의 이동(Queue Shifting)</b>: 요소가 `dequeue`될 때마다 모든 요소를 앞으로 이동시켜야 한다.  
> <b>2. 메모리 낭비(Memory Waste)</b>: `dequeue` 연산이 반복되면 앞 부분의 공간이 낭비된다.  

- 이러한 문제를 해결하기 위해, <b>원형 큐(Circular Queue)</b>가 도입됨


### 2) 원형 큐 (Circular Queue)

![원형 큐](/Resources/Images/원형%20큐.png)  

- 원형 큐는 배열의 <b>마지막 요소 다음에 첫 번째 요소가 연결</b>되어 있다고 가정하는 방식
- 이는 마치 배열을 <b>원형으로 구부려 놓은 것</b>과 같음

> <b>🔧원형 큐의 동작 방식</b>  
> 1. <b>초기 상태</b>: 전단(Front)과 후단(Rear)를 모두 0으로 초기화  
> 2. <b>Enqueue</b>: 현재 후단 위치에 데이터를 삽입하고 후단 위치를 1 증가시킴  
>   - 후단이 배열 끝에 도달했을 경우, 다시 0으로 돌아감 (모듈러 연산 이용)  
> 3. <b>Dequeue</b>: 전단 위치의 요소를 반환하고, 전단 위치를 1 증가시킴  
>   - 전단이 배열 끝에 도달했을 경우, 다시 0으로 돌아감 (모듈러 연산 이용)  

- 하지만 이러한 원형 큐는 <b>❌공백 상태와 포화 상태를 구분할 수가 없다</b>는 문제점이 있음  

![순환 큐의 문제점](/Resources/Images/순환%20큐의%20문제점.png)  

> - <b>공백 상태</b>: 큐가 완전히 비어 있는 상태
> - <b>포화 상태</b>: 큐가 가득 찬 상태  

- 이를 해결하는 방법으로 <b>1)더미 노드 사용법</b>과 <b>2)카운터 변수 사용법</b>이 존재  

> <b>📌더미 노드를 사용하여 한 칸을 항상 비워두는 방법</b>  
> ![더미 노드 사용법](/Resources/Images/순환%20큐의%20문제점%20해결법.png)  
> - 실제 큐의 용량보다 1개 더 큰 배열을 생성  
> - 큐가 가득 찼다고 판단하는 조건: `(rear + 1) % capacity == front`  
> - 큐가 비어있다고 판단하는 조건: `front == rear`  

> <b>📌카운터 변수를 사용하는 방법</b>  
> - 큐에 있는 요소의 개수를 추적하는 카운터 변수를 추가  
> - 큐가 가득 찼다고 판단하는 조건: `count == capacity`  
> - 큐가 비어있다고 판단하는 조건: `count == 0`  

### 3) 연결 리스트 기반 큐

![연결리스트 기반 큐](/Resources/Images/연결리스트%20큐%20구현.png)  

- 연결 리스트 기반 큐는 각 노드가 데이터와 다음 노드를 가리키는 포인터를 가지는 구조
- 크기 제한이 없어 필요에 따라 동적으로 확장이 가능
- 포화 상태를 검사할 필요가 없음
- 메모리를 효율적으로 사용할 수 있음 (필요한 만큼만 할당)
- 다만, 포인터를 위한 추가 메모리가 필요 (4~8 byte)
- 노드 간의 연결을 위한 포인터 조작이 필요  

> <b>🔧연결 리스트 기반 큐 구현에 필요한 요소</b>  
> <b>1. 노드(Node)</b>: 데이터와 다음 노드를 가리키는 포인터를 포함  
> <b>2. front 포인터</b>: 큐의 맨 앞 노드를 가리킴  
> <b>3. rear 포인터</b>: 큐의 맨 뒤 노드를 가리킴  

<br>

# 3. 큐의 시간 복잡도와 특징

| 연산 | 시간 복잡도 | 설명 |
| --- | --- | --- |
| `Enqueue`| $\mathrm{O(1)}$ | 큐의 뒤 쪽에 요소를 추가하는 연산 |
| `Dequeue`| $\mathrm{O(1)}$ | 큐의 앞 쪽에 요소를 제거하는 연산 |
| `Peek`| $\mathrm{O(1)}$ | 큐의 맨 앞 요소를 확인하는 연산 |
| `Search`| $\mathrm{O(N)}$ | 특정 요소 검색을 위해선 최악의 경우, 모든 요소를 하나씩 다 확인해야 함 |

### 데이터의 크기를 알고 있는 경우
- 입력 데이터의 크기를 미리 알고 있다면 <b>원형 큐(Circular Queue)</b>가 효율적
- 원형 큐는 동적 할당이 필요 없어 속도 면에서 빠름
- 메모리 할당/해제 오버헤드가 없어 성능이 일정

### 데이터 크기를 모르는 경우
- 입력 데이터의 크기를 예측할 수 없거나 변동이 심한 경우, <b>연결 리스트 기반 큐</b>가 적합
- 필요에 따라 동적으로 크기가 조정됨
- 메모리 낭비 없이 필요한 만큼만 사용

### 성능 고려
- 원형 큐는 연속된 메모리를 사용하므로 <b>캐시 지역성(cache locality)</b>이 좋아 일반적으로 더 빠름
- 연결 리스트 기반 큐는 노드 생성과 포인터 조작에 따른 오버헤드가 있어 비교적 느릴 수 있음

### 메모리 사용량
- 원형 큐는 최대 크기를 미리 지정해야 하므로 사용하지 않는 공간이 낭비될 수 있음
- 연결 리스트 기반 큐는 필요한 만큼만 메모리를 사용하지만, 포인터 저장을 위한 추가 메모리가 필요
