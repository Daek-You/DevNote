# 1. 배열(Array)이란?

<img src="https://media.geeksforgeeks.org/wp-content/uploads/20230922124049/Array-data-structure.png" width="1200"/>  

- 배열은 <b>`1)동일한 타입의 데이터 요소`</b>들을 <b>`2)연속된 메모리 공간`</b>에 <b>`3)순차적`</b>으로 저장하는 자료구조
- 배열은 컴퓨터 과학의 가장 기본적이고 널리 사용되는 자료구조로, 대부분의 프로그래밍 언어에서 기본적으로 제공
- 생각해보면 배열은 우리 일상에서도 찾아볼 수 있음
    - 책장에 책을 순서대로 꽂아두거나, 주차장에 차를 순서대로 주차하는 것과 비슷  

<br>

# 2. 배열의 구성 요소
### 요소 (Element)

- 배열 내에 저장된 각각의 데이터를 <b>`요소(Element)`</b>라고 함
- 모든 요소는 <b>반드시 동일한 데이터 타입</b>을 가져야 함❗
    - 정수 배열은 모든 요소가 정수
    - 문자 배열은 모든 요소가 문자
    - 객체 배열은 모든 요소가 같은 유형의 객체

### 인덱스 (Index)

- <b>배열 내에서 특정 요소의 위치를 나타내는 숫자</b>
- 대부분의 프로그래밍 언어에서 배열의 인덱스는 `0`부터 시작

<br>

# 3. 배열의 핵심 특징
### 임의 접근(Random Access)

- ✅배열의 핵심 특성 중 하나는, <b>인덱스를 통한 `임의 접근(Random Access)`가 가능</b>하다는 점
- 이를 통해, 배열은 0부터 시작하는 인덱스로 각 요소에 직접 접근이 가능  

![Random Access](/Resources/Images/Random-Access.png)  

> <b>Q. 임의 접근(Random Access) 또는 직접 접근이란?</b>  
> - 기억 장치에서 자료를 읽거나 쓸 때 기억 장소에 관계없이 동일한 접근 시간이 걸리는 접근 방식  
> - 10번, 100번, 100만번 인덱스 등등 어느 곳에 접근하더라도 $\mathrm{O(1)}$의 속도를 낼 수 있음  

- 임의 접근이 가능한 이유는 배열의 다음과 같은 구조적 특성 덕분
    1. 모든 요소가 동일한 데이터 타입을 가지므로, <b>각 요소의 크기가 동일</b>하다.
    2. 요소들이 메모리에 <b>연속적으로 저장</b>된다.
- 이러한 특성을 활용하여, 다음의 수식으로 원하는 요소의 메모리 주소를 직접 계산할 수 있다.
    - 👉🏻 $\mathrm{O(1)}$의 성능을 낼 수 있는 이유  

```bash
요소의 메모리 주소 = 배열의 시작 주소 + (데이터 타입의 크기 * 인덱스)
```  

<br>

# 4. 배열 선언과 사용 방법
### C++ 예시

```cpp
#include <iostream>
using namespace std;

int main() {
	int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
	cout << arr[3] << endl;         // 4 출력
	cout << *(arr + 3) << endl;     // 위와 똑같은 의미의 코드. 4가 출력됨 -> "임의 접근 공식"
}
```  

### Java 예시

```java
public class ArrayDemo {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        
        System.out.println(arr[3]);         // 4 출력
        
        // 자바에는 C++의 포인터 연산(*(arr + 3))과 동일한 문법이 없지만,
        // 같은 결과를 얻기 위해 다음과 같이 접근 가능
        System.out.println(arr[0 + 3]);     // 4 출력
        
        // 자바에서는 배열도 객체이므로 다음과 같은 방식도 가능
        // C++의 포인터 연산과는 다른 개념
        for (int value : arr) {
            System.out.print(value + " ");  // 1 2 3 4 5 6 7 8 9 10 출력
        }
    }
}
```  

<br>

# 5. 배열의 장단점 및 시간 복잡도
### 장점
- <b>빠른 접근 시간</b>: 인덱스를 통해 $\mathrm{O(1)}$ 시간에 요소에 접근이 가능
- <b>메모리 효율성</b>: 연속된 메모리 블록을 사용하여 캐시 지역성이 좋음
- <b>구현 용이성</b>: 간단한 개념으로 쉽게 구현 가능

### 단점
- <b>고정된 크기</b>: 처음 선언한 크기 이상으로 확장하기가 어려움 👉🏻 [동적 배열(Dynamic Array)](https://blog.encrypted.gg/1090)로 어느 정도 극복 가능
- <b>삽입/삭제 비효율성</b>: 배열 중간에 요소를 삽입 or 삭제할 때, 이후 요소들을 모두 이동해야 함

### 시간 복잡도

| 연산 | 시간 복잡도 | 설명 |
| --- | --- | --- |
| <b>접근(Access)</b> | $\mathrm{O(1)}$ | 인덱스로 직접 접근 |
| <b>검색(Search)</b> | $\mathrm{O(N)}$ | 정렬되지 않은 배열에서 선형 검색 |
| <b>삽입(Insertion)</b> | $\mathrm{O(N)}$ | 다른 요소들을 이동해야 함 |
| <b>삭제(Deletion)</b> | $\mathrm{O(N)}$ | 다른 요소들을 이동해야 함 |  
